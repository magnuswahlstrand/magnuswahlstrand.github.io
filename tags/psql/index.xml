<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>psql on wahlstrand.dev</title>
    <link>https://magnuswahlstrand.github.io/tags/psql/</link>
    <description>Recent content in psql on wahlstrand.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 07 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://magnuswahlstrand.github.io/tags/psql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQLALchemy: One to many-relationships</title>
      <link>https://magnuswahlstrand.github.io/post/2022-03-07-one-to-many/</link>
      <pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://magnuswahlstrand.github.io/post/2022-03-07-one-to-many/</guid>
      <description>&lt;p&gt;When learning a new tech stack, the database layer is usually one of the harder and the most fun activities. In my current project, our services are written in Python, and most of them use PostgreSQL for storage.
For Python, the most commonly used SQL library is &lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;. It is usually used as an Objectâ€“relational mapping (&lt;a href=&#34;https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping&#34;&gt;ORM&lt;/a&gt;). While I have used Python in the past, I haven&amp;rsquo;t used either SQLAlchemy or ORMs very much in production. In this article, I will explore how to model relationships in SQLAlchemy.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Audit tables in Postgres</title>
      <link>https://magnuswahlstrand.github.io/post/2022-02-27-audit-logs-in-postgres/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://magnuswahlstrand.github.io/post/2022-02-27-audit-logs-in-postgres/</guid>
      <description>&lt;p&gt;A while back I watched &lt;a href=&#34;https://www.youtube.com/watch?v=j6ow-UemzBc&#34;&gt;this video&lt;/a&gt; (summary &lt;a href=&#34;https://www.infoq.com/news/2018/07/bryzek-microservice-architecture/&#34;&gt;here&lt;/a&gt;) with Michael Bryzek (Flow.io, Gilt). He presented how they do &lt;a href=&#34;https://en.wikipedia.org/wiki/Change_data_capture&#34;&gt;Change Data Capture&lt;/a&gt; (CDC) with PostgreSQL and DynamoDB. One goal with CDC is that changes to databases rows and tables can be propagated to other parts of the system. In microservices systems, this can be used to build read-projections, or just keep local caches of data.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.postgresql.org/&#34;&gt;Postgres&lt;/a&gt; is one of my favorite databases to work with in production (and probably the one I most experience with), but I have little or experience working features such as PostgreSQL triggers and stored procedures. In this blog post, I explore how to use triggers to create a simple audit table in Postgres.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
